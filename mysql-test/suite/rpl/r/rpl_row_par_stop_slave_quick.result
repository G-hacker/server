include/master-slave.inc
[connection master]
#
# Setup
connection slave;
include/stop_slave.inc
SET STATEMENT sql_log_bin=0 FOR call mtr.add_suppression("Can't find record");
ALTER TABLE mysql.gtid_slave_pos ENGINE=InnoDB;
connect slave_lock_extra,127.0.0.1,root,,test,$SLAVE_MYPORT;
CHANGE MASTER TO MASTER_USE_GTID=SLAVE_POS;
include/start_slave.inc
#
# Initialize test data
connection master;
SET STATEMENT sql_log_bin=0 FOR call mtr.add_suppression('Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT.');
SET @@global.binlog_direct_non_transactional_updates= 0;
SET @@session.binlog_direct_non_transactional_updates= 0;
create table ti (a int) engine=innodb;
create table tm (a int) engine=myisam;
insert into ti values (100);
insert into tm values (200);
connection slave;
# Run binlog format independent test cases
#
# Common Test Case 1:
# Using one parallel replication worker thread on workload {T,T}, ensure
# the replica immediately rolls back the transaction and stops the
# SQL thread
connection slave;
include/stop_slave.inc
set @@global.slave_parallel_threads=1;
connection master;
include/save_master_gtid.inc
BEGIN;
insert into ti values (101);
insert into ti values (102);
COMMIT;
insert into ti values (103);
connection slave;
LOCK TABLES ti WRITE;
START SLAVE;
# Wait for replica to begin executing the first transaction
connection slave;
connection slave1;
STOP SLAVE;;
connection slave;
UNLOCK TABLES;
include/wait_for_slave_sql_to_stop.inc
connection slave1;
connection slave;
include/assert.inc [No new rows should have been inserted]
include/assert.inc [GTID slave state should not change]
connection master;
include/save_master_gtid.inc
connection slave;
include/start_slave.inc
include/sync_with_master_gtid.inc
#
# Common Test Case 2:
# Using multiple parallel replication threads (two) on workload {T,T},
# ensure both transactions are rolled back if stop slave is issued
# in the middle of the first transaction.
connection slave;
include/stop_slave.inc
set @@global.slave_parallel_threads=2;
connection master;
include/save_master_gtid.inc
BEGIN;
insert into ti values (104);
insert into ti values (105);
COMMIT;
insert into ti values (106);
connection slave;
LOCK TABLES ti WRITE;
include/start_slave.inc
# Wait for replica to begin executing the first transaction
connection slave;
# Wait for second transaction to begin
connection slave;
connection slave1;
STOP SLAVE;;
connection slave;
UNLOCK TABLES;
include/wait_for_slave_sql_to_stop.inc
connection slave1;
connection slave;
include/assert.inc [No insertions should have committed]
include/assert.inc [GTID slave state should not change]
# Slave should be error-free
include/assert.inc [Slave should be error free]
connection master;
include/save_master_gtid.inc
connection slave;
include/start_slave.inc
include/sync_with_master_gtid.inc
#
# ROW Test Case 1:
# Using an N multi-statement transaction, ensure if STOP SLAVE is
# issued in-between row updates, that the transaction is finished.
connection master;
truncate table ti;
truncate table tm;
# Set up multiple rows to allow a multi-statement update rows event
insert into tm values (201);
insert into tm values (202);
connection slave;
connection slave;
include/stop_slave.inc
set @@global.slave_parallel_threads=1;
connection master;
# Next-to-commit non-transactional transaction should finish
update tm set a=a+1;
include/save_master_gtid.inc
# This should not be committed because it is after next-to-commit
insert into ti values (107);
connection slave;
set @@global.debug_dbug="+d,pause_after_next_row_exec";
START SLAVE;
set debug_sync= "now WAIT_FOR row_executed";
connection slave1;
STOP SLAVE;;
connection slave;
set @@global.debug_dbug="";
set debug_sync= "now SIGNAL continue_row_execution";
connection slave1;
include/wait_for_slave_sql_to_stop.inc
# Slave should be error-free
include/assert.inc [Slave should be error free]
set @@global.debug_dbug="-d,stop_slave_between_rows";
include/start_slave.inc
include/sync_with_master_gtid.inc
#
# ROW Test Case 2:
# Using a T multi-statement transaction, ensure if STOP SLAVE is
# issued in-between row updates, that the transaction is rolled back.
connection master;
truncate table ti;
truncate table tm;
insert into ti values (108);
insert into ti values (109);
connection slave;
connection slave;
include/stop_slave.inc
set @@global.slave_parallel_threads=1;
connection master;
# Next-to-commit transactional multi-row event should be rolled back
include/save_master_gtid.inc
update ti set a=a+1;
insert into ti values (110);
connection slave;
set @@global.debug_dbug="+d,pause_after_next_row_exec";
START SLAVE;
set debug_sync= "now WAIT_FOR row_executed";
connection slave1;
STOP SLAVE;;
connection slave;
set @@global.debug_dbug="";
set debug_sync= "now SIGNAL continue_row_execution";
connection slave1;
include/wait_for_slave_sql_to_stop.inc
include/assert.inc [No new rows should have been inserted]
# Comparing master gtid 0-1-18 to slaves 0-1-18
include/assert.inc [No transactions should have committed]
# Slave should be error-free
include/assert.inc [Slave should be error free]
set @@global.debug_dbug="-d,stop_slave_between_rows";
include/start_slave.inc
include/sync_with_master_gtid.inc
#
# Row Test Case 3:
# Using parallel replication on a workload with the next-to-commit
# transaction as N, such that no other transactions are N, if that
# transaction takes too long on the slave, it should be killed and an
# error message displayed to the user mentioning the harmful N changes.
# Pre-populate data to update
connection master;
TRUNCATE TABLE tm;
insert into tm values (203);
insert into tm values (204);
insert into tm values (205);
connection slave;
include/start_slave.inc
Warnings:
Note	1254	Slave is already running
include/sync_with_master_gtid.inc
include/stop_slave.inc
set @@global.slave_parallel_threads=1;
SET @@GLOBAL.debug_dbug="+d,slave_abort_quick_timeout,pause_after_next_row_exec";
connection master;
include/save_master_gtid.inc
update tm set tm.a=tm.a+1;
insert into ti values (111);
connection slave;
include/start_slave.inc
set debug_sync= "now WAIT_FOR row_executed";
connection slave1;
STOP SLAVE;;
connection slave;
set debug_sync= "now SIGNAL continue_row_execution";
set debug_sync= "now WAIT_FOR row_executed";
# Sleep until slave auto-kill timeout
SET @@GLOBAL.debug_dbug="-d,pause_after_next_row_exec";
set debug_sync= "now SIGNAL continue_row_execution";
include/wait_for_slave_sql_to_stop.inc
connection slave1;
connection slave;
include/assert.inc [GTID slave state should not change]
include/wait_for_slave_sql_error.inc [errno=1593]
connection master;
include/save_master_gtid.inc
connection slave;
# Slave shouldn't be able to re-execute the event because last attempt
# changed the reliant row data
START SLAVE;
include/wait_for_slave_sql_error.inc [errno=1032]
set @@global.slave_exec_mode=IDEMPOTENT;
SET @@GLOBAL.debug_dbug="-d,slave_abort_quick_timeout";
include/start_slave.inc
include/sync_with_master_gtid.inc
set @@global.slave_exec_mode=STRICT;
set debug_sync= "RESET";
#
# Cleanup
connection master;
DROP TABLE ti, tm;
SET @@global.binlog_direct_non_transactional_updates= 1;
include/save_master_gtid.inc
connection slave;
include/sync_with_master_gtid.inc
include/stop_slave.inc
set @@global.debug_dbug="";
set @@global.slave_parallel_threads=0;
include/start_slave.inc
include/rpl_end.inc
# End of tests
