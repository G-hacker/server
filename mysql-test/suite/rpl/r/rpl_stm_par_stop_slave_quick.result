include/master-slave.inc
[connection master]
#
# Setup
connection slave;
include/stop_slave.inc
SET STATEMENT sql_log_bin=0 FOR call mtr.add_suppression('Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT.');
SET STATEMENT sql_log_bin=0 FOR call mtr.add_suppression("Commit failed due to failure of an earlier commit on which this one depends");
# Set slave timeout to force kill worker threads to 4s
SET @@GLOBAL.debug_dbug="+d,slave_abort_quick_timeout";
ALTER TABLE mysql.gtid_slave_pos ENGINE=InnoDB;
change master to master_use_gtid=slave_pos;
include/start_slave.inc
connect slave_lock_extra,127.0.0.1,root,,test,$SLAVE_MYPORT;
#
# Initialize test data
connection master;
set statement sql_log_bin=0 for call mtr.add_suppression('Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT.');
SET @@global.binlog_direct_non_transactional_updates= 0;
SET @@session.binlog_direct_non_transactional_updates= 0;
create table ti (a int primary key) engine=innodb;
create table ti2 (a int) engine=innodb;
create table ti3 (a int) engine=innodb;
create table tm (a int) engine=myisam;
create table tm2 (a int) engine=myisam;
connection slave;
# Run binlog format independent test cases
#
# Common Test Case 1:
# Using one parallel replication worker thread on workload {T,T}, ensure
# the replica immediately rolls back the transaction and stops the
# SQL thread
connection slave;
include/stop_slave.inc
set @@global.slave_parallel_threads=1;
connection master;
include/save_master_gtid.inc
BEGIN;
insert into ti values (100);
insert into ti values (101);
COMMIT;
insert into ti values (102);
connection slave;
LOCK TABLES ti WRITE;
START SLAVE;
# Wait for replica to begin executing the first transaction
connection slave;
connection slave1;
STOP SLAVE;;
connection slave;
UNLOCK TABLES;
include/wait_for_slave_sql_to_stop.inc
connection slave1;
connection slave;
include/assert.inc [No new rows should have been inserted]
include/assert.inc [GTID slave state should not change]
connection master;
include/save_master_gtid.inc
connection slave;
include/start_slave.inc
include/sync_with_master_gtid.inc
#
# Common Test Case 2:
# Using multiple parallel replication threads (two) on workload {T,T},
# ensure both transactions are rolled back if stop slave is issued
# in the middle of the first transaction.
connection slave;
include/stop_slave.inc
set @@global.slave_parallel_threads=2;
connection master;
include/save_master_gtid.inc
BEGIN;
insert into ti values (103);
insert into ti values (104);
COMMIT;
insert into ti values (105);
connection slave;
LOCK TABLES ti WRITE;
include/start_slave.inc
# Wait for replica to begin executing the first transaction
connection slave;
# Wait for second transaction to begin
connection slave;
connection slave1;
STOP SLAVE;;
connection slave;
UNLOCK TABLES;
include/wait_for_slave_sql_to_stop.inc
connection slave1;
connection slave;
include/assert.inc [No insertions should have committed]
include/assert.inc [GTID slave state should not change]
# Slave should be error-free
include/assert.inc [Slave should be error free]
connection master;
include/save_master_gtid.inc
connection slave;
include/start_slave.inc
include/sync_with_master_gtid.inc
#
# Statement Test Case 1:
# Using one parallel replication worker thread on workload {N,T}, ensure
# the replica finishes the non-transactional transaction, and does not
# start the next
connection slave;
include/stop_slave.inc
set @@global.slave_parallel_threads=1;
connection master;
BEGIN;
insert into ti values (106);
insert into tm values (200);
Warnings:
Note	1592	Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it accesses a non-transactional table after accessing a transactional table within the same transaction
insert into tm2 values (300);
Warnings:
Note	1592	Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it accesses a non-transactional table after accessing a transactional table within the same transaction
insert into ti values (107);
COMMIT;
include/save_master_gtid.inc
insert into ti values (108);
connection slave;
lock tables tm2 write;
START SLAVE;
# Wait for replica to get stuck on held lock
connection slave;
connection slave1;
STOP SLAVE;;
connection slave;
# Unlock row-level lock holding transaction
UNLOCK TABLES;
include/wait_for_slave_sql_to_stop.inc
connection slave1;
connection slave;
include/assert.inc [Transaction should have committed]
include/assert.inc [N should have been applied]
# Slave should be error-free
include/assert.inc [Slave should be error free]
connection master;
include/save_master_gtid.inc
connection slave;
include/start_slave.inc
include/sync_with_master_gtid.inc
#
# Statement Test Case 2:
# If STOP SLAVE is issued on a parallel slave, such that the next to
# commit transaction is T; even if the next event from the group will
# commit the transaction (e.g. XID_EVENT), the transaction should be
# stopped and rolled back.
connection slave;
include/stop_slave.inc
set @@global.slave_parallel_threads=1;
connection master;
insert into ti values (109);
insert into ti values (110);
include/save_master_gtid.inc
connection slave;
LOCK TABLES ti WRITE;
include/start_slave.inc
# Wait for replica to begin executing the first transaction
connection slave;
connection slave1;
STOP SLAVE;;
connection slave;
UNLOCK TABLES;
include/wait_for_slave_sql_to_stop.inc
connection slave1;
connection slave;
include/assert.inc [No insertions should have committed]
include/assert.inc [GTID slave state should increment to the first transaction]
include/start_slave.inc
include/sync_with_master_gtid.inc
#
# Statement Test Case 3:
# Using multiple parallel replication threads on a workload with a
# non-transactional transaction in-between transactional transactions..
#  3a: with AGGRESSIVE replication where the N statement has been
#      executed already, all transactions up to and including N should
#      be replicated, and all transactions afterwards should be rolled
#      back.
#  3b: with MINIMAL replication, the N statement should not execute
#      concurrently, but should wait along with the other later
#      transactions, and all future transactions except the first should
#      be rolled back.
#  3a: with AGGRESSIVE replication where the slave errors on the first
#      transaction after having executed the later non-transactional
#      part, error..
connection slave;
include/stop_slave.inc
set @@global.slave_parallel_threads=4;
connection slave;
#
# 3a: slave_parallel_mode=AGGRESSIVE
set @@global.slave_parallel_mode=AGGRESSIVE;
connection slave;
connection master;
connection master;
insert into ti values (111);
BEGIN;
insert into ti3 values (500);
insert into tm values (202);
Warnings:
Note	1592	Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it accesses a non-transactional table after accessing a transactional table within the same transaction
insert into ti3 values (501);
COMMIT;
insert into ti2 values (400);
insert into ti values (112);
include/save_master_gtid.inc
connection slave;
LOCK TABLES ti WRITE;
connection slave_lock_extra;
LOCK TABLES ti2 WRITE;
include/start_slave.inc
# Wait for replica to halt due to locks and dependency requirements
connection slave;
connection slave1;
STOP SLAVE;;
connection slave;
UNLOCK TABLES;
connection slave_lock_extra;
UNLOCK TABLES;
connection slave1;
connection slave;
include/wait_for_slave_sql_to_stop.inc
include/assert.inc [The entirety of the first two transactions should have committed with AGGRESSIVE parallelization]
include/assert.inc [Slave state should be consistent]
connection master;
include/save_master_gtid.inc
connection slave;
include/start_slave.inc
include/sync_with_master_gtid.inc
include/stop_slave.inc
connection slave;
#
# 3b: slave_parallel_mode=MINIMAL
set @@global.slave_parallel_mode=MINIMAL;
connection slave;
connection master;
connection master;
insert into ti values (113);
BEGIN;
insert into ti3 values (502);
insert into tm values (203);
Warnings:
Note	1592	Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it accesses a non-transactional table after accessing a transactional table within the same transaction
insert into ti3 values (503);
COMMIT;
insert into ti2 values (401);
insert into ti values (114);
include/save_master_gtid.inc
connection slave;
LOCK TABLES ti WRITE;
connection slave_lock_extra;
LOCK TABLES ti2 WRITE;
include/start_slave.inc
# Wait for replica to halt due to locks and dependency requirements
connection slave;
connection slave1;
STOP SLAVE;;
connection slave;
UNLOCK TABLES;
connection slave_lock_extra;
UNLOCK TABLES;
connection slave1;
connection slave;
include/wait_for_slave_sql_to_stop.inc
include/assert.inc [All transactions should have rolled back with MINIMAL parallelization]
include/assert.inc [Slave state should be consistent]
connection master;
include/save_master_gtid.inc
connection slave;
include/start_slave.inc
include/sync_with_master_gtid.inc
include/stop_slave.inc
connection slave;
#
# 3c: ERROR slave_parallel_mode=AGGRESSIVE
set @@global.slave_parallel_mode=AGGRESSIVE;
connection slave;
connection master;
connection master;
# Create a transaction which takes longer than the allowed SLAVE STOP time
BEGIN;
insert into ti values (115+SLEEP(2.5));
Warnings:
Note	1592	Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it uses a system function that may return a different value on the slave
insert into ti values (116+SLEEP(2.5));
Warnings:
Note	1592	Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it uses a system function that may return a different value on the slave
insert into ti values (117+SLEEP(2.5));
Warnings:
Note	1592	Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it uses a system function that may return a different value on the slave
COMMIT;
BEGIN;
insert into ti3 values (504);
insert into tm values (204);
Warnings:
Note	1592	Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it accesses a non-transactional table after accessing a transactional table within the same transaction
insert into ti3 values (505);
COMMIT;
insert into ti2 values (402);
insert into ti values (118);
connection slave;
LOCK TABLES ti WRITE;
connection slave_lock_extra;
LOCK TABLES ti2 WRITE;
include/start_slave.inc
# Wait for replica to halt due to locks and dependency requirements
connection slave;
connection slave1;
STOP SLAVE;;
connection slave;
UNLOCK TABLES;
connection slave_lock_extra;
UNLOCK TABLES;
connection slave1;
connection slave;
include/wait_for_slave_sql_error.inc [errno=1593]
include/assert.inc [One row should be new from the non-transactional statement of the second transaction]
include/assert.inc [Slave state should be consistent]
connection master;
include/save_master_gtid.inc
connection slave;
include/start_slave.inc
include/sync_with_master_gtid.inc
include/stop_slave.inc
include/start_slave.inc
#
# Cleanup
connection master;
DROP TABLE ti, tm, ti2, tm2, ti3;
SET @@global.binlog_direct_non_transactional_updates= 1;
include/save_master_gtid.inc
connection slave;
include/sync_with_master_gtid.inc
include/stop_slave.inc
set @@global.slave_parallel_threads=0;
set @@global.slave_domain_parallel_threads=0;
set @@global.slave_parallel_mode=conservative;
set @@global.debug_dbug="";
include/start_slave.inc
include/rpl_end.inc
# End of tests
