#
# Validate that STOP SLAVE works in a timely manner on a parallel replica with
# ROW binary logging format.
#
--source include/have_debug.inc
--source include/master-slave.inc
--source include/have_innodb.inc
--source include/have_binlog_format_statement.inc

--echo #
--echo # Setup
--connection slave
--source include/stop_slave.inc
SET STATEMENT sql_log_bin=0 FOR call mtr.add_suppression('Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT.');
SET STATEMENT sql_log_bin=0 FOR call mtr.add_suppression("Commit failed due to failure of an earlier commit on which this one depends");
--let $old_threads= `SELECT @@global.slave_parallel_threads`
--let $old_domain_threads= `SELECT @@global.slave_domain_parallel_threads`
--let $old_slave_mode= `SELECT @@global.slave_parallel_mode`
--let $old_debug_dbug= `SELECT @@global.debug_dbug`

--echo # Set slave timeout to force kill worker threads to 4s
SET @@GLOBAL.debug_dbug="+d,slave_abort_quick_timeout";
ALTER TABLE mysql.gtid_slave_pos ENGINE=InnoDB;
change master to master_use_gtid=slave_pos;
--source include/start_slave.inc
--connect(slave_lock_extra,127.0.0.1,root,,test,$SLAVE_MYPORT)

--echo #
--echo # Initialize test data
--connection master
set statement sql_log_bin=0 for call mtr.add_suppression('Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT.');
--let $old_binlog_direct= `SELECT @@global.binlog_direct_non_transactional_updates`
SET @@global.binlog_direct_non_transactional_updates= 0;
SET @@session.binlog_direct_non_transactional_updates= 0;
create table ti (a int primary key) engine=innodb;
create table ti2 (a int) engine=innodb;
create table ti3 (a int) engine=innodb;
create table tm (a int) engine=myisam;
create table tm2 (a int) engine=myisam;
--let $ti_ctr= 100
--let $tm_ctr= 200
--let $tm2_ctr= 300
--let $ti2_ctr= 400
--let $ti3_ctr= 500
--sync_slave_with_master

--echo # Run binlog format independent test cases
--source include/rpl_par_stop_slave_quick_common.test


--echo #
--echo # Statement Test Case 1:
--echo # Using one parallel replication worker thread on workload {N,T}, ensure
--echo # the replica finishes the non-transactional transaction, and does not
--echo # start the next

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=1;
--let $row_count_initial=`select count(*) from (select * from ti UNION ALL select * from tm UNION ALL select * from tm2) t`

--connection master
BEGIN;
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--eval insert into tm values ($tm_ctr)
--inc $tm_ctr
--eval insert into tm2 values ($tm2_ctr)
--inc $tm_ctr
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
COMMIT;
--source include/save_master_gtid.inc

--eval insert into ti values ($ti_ctr)
--inc $ti_ctr

--connection slave
lock tables tm2 write;
START SLAVE;

--echo # Wait for replica to get stuck on held lock
--connection slave
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--connection slave1
--send STOP SLAVE;

--connection slave
--echo # Unlock row-level lock holding transaction
UNLOCK TABLES;
--source include/wait_for_slave_sql_to_stop.inc

--connection slave1
--reap
--connection slave

--let $row_count_end=`select count(*) from (select * from ti UNION ALL select * from tm UNION ALL select * from tm2) t`
--let $row_count_diff=`select ($row_count_end-$row_count_initial)`
--let $assert_text= Transaction should have committed
--let $assert_cond= $row_count_diff = 4
--source include/assert.inc

--let $slave_gtid= `select @@global.gtid_slave_pos`
# N is the non-transactional transaction
--let $assert_text= N should have been applied
--let $assert_cond= $master_pos = $slave_gtid
--source include/assert.inc

--echo # Slave should be error-free
let $last_error = query_get_value("SHOW SLAVE STATUS", Last_SQL_Errno, 1);
--let $assert_text= Slave should be error free
--let $assert_cond= $last_error = 0
--source include/assert.inc

--connection master
--source include/save_master_gtid.inc

--connection slave
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # Statement Test Case 2:
--echo # If STOP SLAVE is issued on a parallel slave, such that the next to
--echo # commit transaction is T; even if the next event from the group will
--echo # commit the transaction (e.g. XID_EVENT), the transaction should be
--echo # stopped and rolled back.

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=1;
--let $row_count_initial=`select count(*) from (select * from ti UNION ALL select * from tm) t`

--connection master
--let $master_gtid_cmp= `select @@global.gtid_binlog_pos`
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--source include/save_master_gtid.inc

--connection slave
LOCK TABLES ti WRITE;
--source include/start_slave.inc

--echo # Wait for replica to begin executing the first transaction
--connection slave
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--connection slave1
--send STOP SLAVE;

--connection slave
UNLOCK TABLES;
--source include/wait_for_slave_sql_to_stop.inc

--connection slave1
--reap
--connection slave

--let $row_count_end=`select count(*) from (select * from ti UNION ALL select * from tm) t`
--let $row_count_diff=`select ($row_count_end-$row_count_initial)`
--let $assert_text= No insertions should have committed
--let $assert_cond= $row_count_diff = 0
--source include/assert.inc

--let $slave_gtid= `select @@global.gtid_slave_pos`
--let $assert_text= GTID slave state should increment to the first transaction
--let $assert_cond= $master_gtid_cmp = $slave_gtid
--source include/assert.inc

--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # Statement Test Case 3:
--echo # Using multiple parallel replication threads on a workload with a
--echo # non-transactional transaction in-between transactional transactions..
--echo #  3a: with AGGRESSIVE replication where the N statement has been
--echo #      executed already, all transactions up to and including N should
--echo #      be replicated, and all transactions afterwards should be rolled
--echo #      back.
--echo #  3b: with MINIMAL replication, the N statement should not execute
--echo #      concurrently, but should wait along with the other later
--echo #      transactions, and all future transactions except the first should
--echo #      be rolled back.
--echo #  3a: with AGGRESSIVE replication where the slave errors on the first
--echo #      transaction after having executed the later non-transactional
--echo #      part, error..


--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=4;

--let $mode_ctr=3
while ($mode_ctr)
{
    --connection slave
    if ($mode_ctr == 3)
    {
        --echo #
        --echo # 3a: slave_parallel_mode=AGGRESSIVE
        set @@global.slave_parallel_mode=AGGRESSIVE;
    }
    if ($mode_ctr == 2)
    {
        --echo #
        --echo # 3b: slave_parallel_mode=MINIMAL
        set @@global.slave_parallel_mode=MINIMAL;
    }
    if ($mode_ctr == 1)
    {
        --echo #
        --echo # 3c: ERROR slave_parallel_mode=AGGRESSIVE
        set @@global.slave_parallel_mode=AGGRESSIVE;
    }

    --connection slave
    --let $row_count_initial=`select count(*) from (select * from ti UNION ALL select * from tm UNION ALL select * from ti2 UNION ALL select * from tm2 UNION ALL select * from ti3) t`

    --connection master
    if ($mode_ctr <= 2)
    {
        --let $master_gtid_cmp= `select @@global.gtid_binlog_pos`
    }

    --connection master
    if ($mode_ctr == 1)
    {
        --echo # Create a transaction which takes longer than the allowed SLAVE STOP time
        BEGIN;
        --eval insert into ti values ($ti_ctr+SLEEP(2.5))
        --inc $ti_ctr
        --eval insert into ti values ($ti_ctr+SLEEP(2.5))
        --inc $ti_ctr
        --eval insert into ti values ($ti_ctr+SLEEP(2.5))
        --inc $ti_ctr
        COMMIT;
    }
    if ($mode_ctr > 1)
    {
        --eval insert into ti values ($ti_ctr)
        --inc $ti_ctr
    }

    BEGIN;
    --eval insert into ti3 values ($ti3_ctr)
    --inc $ti3_ctr
    --let $reapplied_tm_id= $tm_ctr
    --eval insert into tm values ($tm_ctr)
    --inc $tm_ctr
    --eval insert into ti3 values ($ti3_ctr)
    --inc $ti3_ctr
    COMMIT;
    if ($mode_ctr == 3)
    {
        # AGGRESSIVE mode should allow N trx to complete
        --let $master_gtid_cmp= `select @@global.gtid_binlog_pos`
    }
    --eval insert into ti2 values ($ti2_ctr)
    --inc $ti2_ctr
    --eval insert into ti values ($ti_ctr)
    --inc $ti_ctr
    if ($mode_ctr > 1)
    {
        --source include/save_master_gtid.inc
    }

    --connection slave
    LOCK TABLES ti WRITE;
    --connection slave_lock_extra
    LOCK TABLES ti2 WRITE;

    --source include/start_slave.inc

    --echo # Wait for replica to halt due to locks and dependency requirements
    --connection slave

    if ($mode_ctr == 3)
    {
        # AGGRESSIVE allows for more concurrency that we need to wait for
        --let $wait_condition= SELECT count(*)=3 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
        --source include/wait_condition.inc
        --let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for prior transaction to commit' and  command LIKE 'Slave_worker';
        --source include/wait_condition.inc
    }
    if ($mode_ctr == 2)
    {
        # MINIMAL will only have the first transaction begun
        --let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
        --source include/wait_condition.inc
        --let $wait_condition= SELECT count(*)=3 FROM information_schema.processlist WHERE state LIKE 'Waiting for prior transaction to start commit%' and  command LIKE 'Slave_worker';
        --source include/wait_condition.inc
    }

    --connection slave1
    --send STOP SLAVE;
    --connection slave
    UNLOCK TABLES;
    --connection slave_lock_extra
    UNLOCK TABLES;

    --connection slave1
    --reap
    --connection slave

    if ($mode_ctr == 1)
    {
        --let $slave_sql_errno= 1593
        --source include/wait_for_slave_sql_error.inc
    }
    if ($mode_ctr > 1)
    {
        --source include/wait_for_slave_sql_to_stop.inc
    }

    --let $row_count_end=`select count(*) from (select * from ti UNION ALL select * from tm UNION ALL select * from ti2 UNION ALL select * from tm2 UNION ALL select * from ti3) t`
    --let $row_count_diff=`select ($row_count_end-$row_count_initial)`

    if ($mode_ctr == 3)
    {
        --let $assert_text= The entirety of the first two transactions should have committed with AGGRESSIVE parallelization
        --let $assert_cond= $row_count_diff = 4
    }
    if ($mode_ctr == 2)
    {
        --let $assert_text= All transactions should have rolled back with MINIMAL parallelization
        --let $assert_cond= $row_count_diff = 0
    }

    if ($mode_ctr == 1)
    {
        --let $assert_text= One row should be new from the non-transactional statement of the second transaction
        --let $assert_cond= $row_count_diff = 1
    }

    --source include/assert.inc

    --let $slave_gtid= `select @@global.gtid_slave_pos`
    --let $assert_text= Slave state should be consistent
    --let $assert_cond= $master_gtid_cmp = $slave_gtid
    --source include/assert.inc

    --connection master
    --source include/save_master_gtid.inc
    --connection slave
    --source include/start_slave.inc
    --source include/sync_with_master_gtid.inc

    --source include/stop_slave.inc
    --dec $mode_ctr
}
--source include/start_slave.inc


--echo #
--echo # Cleanup
--connection master
DROP TABLE ti, tm, ti2, tm2, ti3;
--eval SET @@global.binlog_direct_non_transactional_updates= $old_binlog_direct
--source include/save_master_gtid.inc

--connection slave
--source include/sync_with_master_gtid.inc
--source include/stop_slave.inc
--eval set @@global.slave_parallel_threads=$old_threads
--eval set @@global.slave_domain_parallel_threads=$old_domain_threads
--eval set @@global.slave_parallel_mode=$old_slave_mode
--eval set @@global.debug_dbug="$old_debug_dbug"
--source include/start_slave.inc

--source include/rpl_end.inc

--echo # End of tests
